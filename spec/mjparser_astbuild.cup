package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:
    Logger log = Logger.getLogger(getClass());
    int errorCount = 0;

    private String format_message(String message, int left, int right) {
        if (left <= 0) return message;
        StringBuilder info = new StringBuilder(((MJLexer) getScanner()).fileName);
        info.append(':');
        errorCount++;
        info.append(left).append(':');
        if (right > 0) info.append(right).append(':');
        return info.append(' ').append(message).toString();
    }

    private String format_message(String message, Object info) {
        if (info instanceof Symbol) {
            Symbol sym = (Symbol) info;
            return format_message(message, sym.left, sym.right);
        }
        return format_message(message, -1, -1);
    }

    public void report_error(String message, int left, int right) {
        String formattedMessage = format_message(message, left, right);
        log.error(formattedMessage);
        System.err.println(formattedMessage);
    }

    public void report_error(String message, Object info) {
        String formattedMessage = format_message(message, info);
        log.error(formattedMessage);
        System.err.println(formattedMessage);
    }

    public void report_fatal_error(String message, Object info) throws Exception {
        done_parsing();
        String formattedMessage = format_message(message, info);
        log.fatal(formattedMessage);
        System.err.println(formattedMessage);
        throw new Exception("Cannot recover from previous error(s)!");
    }

    public void syntax_error(Symbol cur_token) {
        report_error("Syntax error!", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
        report_fatal_error("Unrecovered syntax error! Recovery impossible!", cur_token);
    }

    public int getErrorCount() { return errorCount; }
:}

scan with {:
    Symbol s = getScanner().next_token();
    if (s != null && s.value != null)
        log.info(s.toString() + (s.value != null ? " " + s.value.toString() : ""));
    return s;
:}

/* Keywords */
terminal PROGRAM, BREAK, CLASS, ABSTRACT, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, FOR, EXTENDS, CONTINUE,
         FOREACH, PUBLIC, PROTECTED, PRIVATE;

/* Operators */
terminal PLUS, MINUS, ASTERISK, SLASH, PERCENT, EQL, NEQ, GRT, GEQ, LSS, LEQ, AND, OR, ASSIGN, PLUSPLUS, MINUSMINUS,
         PLUS_ASSIGN, MINUS_ASSIGN, ASTERISK_ASSIGN, SLASH_ASSIGN, PERCENT_ASSIGN;

/* Punctuation symbols */
terminal LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE, COLON, SEMICOLON, COMMA, DOT;

/* Types and identifier */
terminal Integer INT;
terminal Character CHAR;
terminal Boolean BOOL;
terminal String IDENT;

/* Main non-terminals */
nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgramName, Type;
nonterminal OptProgramDeclList OptProgramDeclList;
nonterminal ProgramDecl ProgramDecl;
nonterminal OptMethodDeclList OptMethodDeclList;

/* Const Declarations */
nonterminal ConstDecl ConstDecl;
nonterminal ConstAssignmentList ConstAssignmentList;
nonterminal ConstAssignment ConstAssignment;
nonterminal Const Const;
nonterminal OptSign OptSign;

/* Global Var Declarations */
nonterminal VarDecl VarDecl;
nonterminal VarList VarList;
nonterminal Var Var;
nonterminal OptArrayBrackets OptArrayBrackets;

/* Class Declarations */
nonterminal ClassDecl ClassDecl;
nonterminal ClassHeader ClassHeader;
nonterminal AccessModifier AccessModifier;
nonterminal OptClassBaseType OptClassBaseType;

/* Class Var Declarations */
nonterminal OptClassVarDeclList OptClassVarDeclList;
nonterminal ClassVarDecl ClassVarDecl;
nonterminal ClassVarList ClassVarList;
nonterminal ClassVar ClassVar;

/* Class Method Declarations */
nonterminal OptClassMethodDeclList OptClassMethodDeclList;
nonterminal ClassMethodDeclList ClassMethodDeclList;
nonterminal ClassMethodDecl ClassMethodDecl;

/* Abstract Class Declarations */
nonterminal AbstractClassDecl AbstractClassDecl;
nonterminal AbstractClassHeader AbstractClassHeader;

/* Abstract Class Method Declarations */
nonterminal OptAbstractClassMethodDeclList OptAbstractClassMethodDeclList;
nonterminal AbstractClassMethodDeclList AbstractClassMethodDeclList;
nonterminal AbstractClassMethodDecl AbstractClassMethodDecl;

/* Method Declarations */
nonterminal MethodDecl MethodDecl;
nonterminal AbstractMethodDecl AbstractMethodDecl;
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodHeader, AbstractMethodHeader, RetType;

/* Formal Parameters */
nonterminal OptFormalParamList OptFormalParamList;
nonterminal FormalParamList FormalParamList;
nonterminal FormalParam FormalParam;

/* Local Var Declarations */
nonterminal OptLocalVarDeclList OptLocalVarDeclList;
nonterminal LocalVarDecl LocalVarDecl;
nonterminal LocalVarList LocalVarList;
nonterminal LocalVar LocalVar;

/* Statement-related non-terminals */
nonterminal OptStatementList OptStatementList;
nonterminal Statement Statement;
nonterminal OptDesignatorStatement OptDesignatorStatement;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal OptElseStatement OptElseStatement;
nonterminal PrintExpr PrintExpr;
nonterminal AssignExpr AssignExpr;

/* Designator-related non-terminals */
nonterminal Designator Designator;
nonterminal OptDesignatorPartList OptDesignatorPartList;
nonterminal DesignatorPart DesignatorPart;

/* Expression-related non-terminals */
nonterminal OptExpr OptExpr;
nonterminal Expr Expr;

/* Actual Parameters */
nonterminal OptActualParamList OptActualParamList;
nonterminal ActualParamList ActualParamList;
nonterminal ActualParam ActualParam;

/* Relational Operators */
nonterminal ForCondition ForCondition;
nonterminal Condition Condition;
nonterminal CondTerm CondTerm;
nonterminal CondFact CondFact;
nonterminal Relop Relop;

/* Additive Operators */
nonterminal OptAddopExprList OptAddopExprList;
nonterminal Addop Addop;
nonterminal AddopLeft AddopLeft;
nonterminal AddopRight AddopRight;

/* Multiplicative Operators */
nonterminal Term Term;
nonterminal Factor Factor;
nonterminal ConstFactor ConstFactor;
nonterminal OptMulopExprList OptMulopExprList;
nonterminal Mulop Mulop;
nonterminal MulopLeft MulopLeft;
nonterminal MulopRight MulopRight;

/* Assignment Operators */
nonterminal Assignop Assignop;

/* Precedence for ELSE terminal for if-else statement */
precedence left ELSE;

/* Main non-terminals */

Program ::= (Program) PROGRAM ProgramName:P1 OptProgramDeclList:O2 LBRACE OptMethodDeclList:O3 RBRACE {: RESULT=new Program(P1, O2, O3); RESULT.setLine(P1left); :};

ProgramName ::= (ProgramName) IDENT:name {: RESULT=new ProgramName(name); RESULT.setLine(nameleft); :};

Type ::= (Type) IDENT:name {: RESULT=new Type(name); RESULT.setLine(nameleft); :};

OptProgramDeclList ::= (ProgramDeclarations) OptProgramDeclList:O1 ProgramDecl:P2 {: RESULT=new ProgramDeclarations(O1, P2); RESULT.setLine(O1left); :}
                     | (NoProgramDeclarations) {: RESULT=new NoProgramDeclarations(); :} /* epsilon */
                     ;

ProgramDecl ::= (ProgramConstDeclaration) ConstDecl:C1 {: RESULT=new ProgramConstDeclaration(C1); RESULT.setLine(C1left); :}
              | (ProgramVarDeclaration) VarDecl:V1 {: RESULT=new ProgramVarDeclaration(V1); RESULT.setLine(V1left); :}
              | (ProgramClassDeclaration) ClassDecl:C1 {: RESULT=new ProgramClassDeclaration(C1); RESULT.setLine(C1left); :}
              | (ProgramAbstractClassDeclaration) AbstractClassDecl:A1 {: RESULT=new ProgramAbstractClassDeclaration(A1); RESULT.setLine(A1left); :}
              ;

OptMethodDeclList ::= (MethodDeclarations) OptMethodDeclList:O1 MethodDecl:M2 {: RESULT=new MethodDeclarations(O1, M2); RESULT.setLine(O1left); :}
                    | (NoMethodDeclarations) {: RESULT=new NoMethodDeclarations(); :} /* epsilon */
                    ;

/* Const Declarations */

ConstDecl ::= (ConstDeclaration) CONST Type:type ConstAssignmentList:C1 SEMICOLON {: RESULT=new ConstDeclaration(type, C1); RESULT.setLine(typeleft); :};

ConstAssignmentList ::= (ConstAssignments) ConstAssignmentList:C1 COMMA ConstAssignment:C2 {: RESULT=new ConstAssignments(C1, C2); RESULT.setLine(C1left); :}
                      | (SingleConstAssignment) ConstAssignment:C1 {: RESULT=new SingleConstAssignment(C1); RESULT.setLine(C1left); :}
                      ;

ConstAssignment ::= (ConstAssignment) IDENT:name ASSIGN Const:value {: RESULT=new ConstAssignment(name, value); RESULT.setLine(nameleft); :};

Const ::= (ConstInt) OptSign:sign INT:value {: RESULT=new ConstInt(sign, value); RESULT.setLine(signleft); :}
        | (ConstChar) CHAR:value {: RESULT=new ConstChar(value); RESULT.setLine(valueleft); :}
        | (ConstBool) BOOL:value {: RESULT=new ConstBool(value); RESULT.setLine(valueleft); :}
        ;

OptSign ::= (Negative) MINUS {: RESULT=new Negative(); :}
          | (ExplicitlyPositive) PLUS {: RESULT=new ExplicitlyPositive(); :}
          | (ImplicitlyPositive) {: RESULT=new ImplicitlyPositive(); :} /* epsilon */
          ;

/* Var Declarations */

VarDecl ::= (VarDeclaration) Type:type VarList:V1 SEMICOLON {: RESULT=new VarDeclaration(type, V1); RESULT.setLine(typeleft); :};

VarList ::= (Variables) VarList:V1 COMMA Var:V2 {: RESULT=new Variables(V1, V2); RESULT.setLine(V1left); :}
          | (SingleVariable) Var:V1 {: RESULT=new SingleVariable(V1); RESULT.setLine(V1left); :}
          ;

Var ::= (Variable) IDENT:name OptArrayBrackets:O1 {: RESULT=new Variable(name, O1); RESULT.setLine(nameleft); :};

OptArrayBrackets ::= (ArrayBrackets) LBRACK RBRACK {: RESULT=new ArrayBrackets(); :}
                   | (NoArrayBrackets) {: RESULT=new NoArrayBrackets(); :} /* epsilon */
                   ;

/* Class Declarations */

ClassDecl ::= (ClassDeclaration) ClassHeader:C1 LBRACE OptClassVarDeclList:O2 OptClassMethodDeclList:O3 RBRACE {: RESULT=new ClassDeclaration(C1, O2, O3); RESULT.setLine(C1left); :};

ClassHeader ::= (ClassHeader) CLASS IDENT:name OptClassBaseType:O1 {: RESULT=new ClassHeader(name, O1); RESULT.setLine(nameleft); :};

AccessModifier ::= (PublicAccess) PUBLIC {: RESULT=new PublicAccess(); :}
                 | (ProtectedAccess) PROTECTED {: RESULT=new ProtectedAccess(); :}
                 | (PrivateAccess) PRIVATE {: RESULT=new PrivateAccess(); :}
                 ;

OptClassBaseType ::= (ClassBaseType) EXTENDS Type:type {: RESULT=new ClassBaseType(type); RESULT.setLine(typeleft); :}
                   | (NoClassBaseType) {: RESULT=new NoClassBaseType(); :} /* epsilon */
                   | (ErrorClassBaseTypeAfterExtends) EXTENDS error {: parser.report_error("Invalid class base type declaration!", null); :} {: RESULT=new ErrorClassBaseTypeAfterExtends(); :}
                   | (ErrorClassBaseTypeBeforeExtends) error {: parser.report_error("Invalid class base type declaration!", null); :} {: RESULT=new ErrorClassBaseTypeBeforeExtends(); :}
                   ;

/* Class Var Declarations */

OptClassVarDeclList ::= (ClassVarDeclarations) OptClassVarDeclList:O1 ClassVarDecl:C2 {: RESULT=new ClassVarDeclarations(O1, C2); RESULT.setLine(O1left); :}
                      | (NoClassVarDeclarations) {: RESULT=new NoClassVarDeclarations(); :} /* epsilon */
                      ;

ClassVarDecl ::= (ClassVarDeclaration) AccessModifier:access Type:type ClassVarList:C1 SEMICOLON {: RESULT=new ClassVarDeclaration(access, type, C1); RESULT.setLine(accessleft); :};

ClassVarList ::= (ClassVariables) ClassVarList:C1 COMMA ClassVar:C2 {: RESULT=new ClassVariables(C1, C2); RESULT.setLine(C1left); :}
               | (SingleClassVariable) ClassVar:C1 {: RESULT=new SingleClassVariable(C1); RESULT.setLine(C1left); :}
               ;

ClassVar ::= (ClassVariable) IDENT:name OptArrayBrackets:O1 {: RESULT=new ClassVariable(name, O1); RESULT.setLine(nameleft); :};

/* Class Method Declarations */

OptClassMethodDeclList ::= (ClassMethodDeclarations) LBRACE ClassMethodDeclList:C1 RBRACE {: RESULT=new ClassMethodDeclarations(C1); RESULT.setLine(C1left); :}
                         | (NoClassMethodDeclarations) {: RESULT=new NoClassMethodDeclarations(); :} /* epsilon */
                         ;

ClassMethodDeclList ::= (MultipleClassMethodDeclarations) ClassMethodDeclList:C1 ClassMethodDecl:C2 {: RESULT=new MultipleClassMethodDeclarations(C1, C2); RESULT.setLine(C1left); :}
                      | (SingleClassMethodDeclaration) ClassMethodDecl:C1 {: RESULT=new SingleClassMethodDeclaration(C1); RESULT.setLine(C1left); :}
                      ;

ClassMethodDecl ::= (ClassMethodDeclaration) AccessModifier:access MethodDecl:method {: RESULT=new ClassMethodDeclaration(access, method); RESULT.setLine(accessleft); :};

/* Abstract Class Declarations */

AbstractClassDecl ::= (AbstractClassDeclaration) AbstractClassHeader:A1 LBRACE OptClassVarDeclList:O2 OptAbstractClassMethodDeclList:O3 RBRACE {: RESULT=new AbstractClassDeclaration(A1, O2, O3); RESULT.setLine(A1left); :};

AbstractClassHeader ::= (AbstractClassHeader) ABSTRACT CLASS IDENT:name OptClassBaseType:O1 {: RESULT=new AbstractClassHeader(name, O1); RESULT.setLine(nameleft); :};

/* Abstract Class Method Declarations */

OptAbstractClassMethodDeclList ::= (AbstractClassMethods) LBRACE AbstractClassMethodDeclList:A1 RBRACE {: RESULT=new AbstractClassMethods(A1); RESULT.setLine(A1left); :}
                                 | (NoAbstractClassMethods) {: RESULT=new NoAbstractClassMethods(); :} /* epsilon */
                                 ;

AbstractClassMethodDeclList ::= (MultipleAbstractClassMethods) AbstractClassMethodDeclList:A1 AbstractClassMethodDecl:A2 {: RESULT=new MultipleAbstractClassMethods(A1, A2); RESULT.setLine(A1left); :}
                              | (SingleAbstractClassMethod) AbstractClassMethodDecl:A1 {: RESULT=new SingleAbstractClassMethod(A1); RESULT.setLine(A1left); :}
                              ;

AbstractClassMethodDecl ::= (AbstractClassMethodDeclaration) AccessModifier:access MethodDecl:method {: RESULT=new AbstractClassMethodDeclaration(access, method); RESULT.setLine(accessleft); :}
                          | (AbstractClassAbstractMethodDeclaration) AccessModifier:access AbstractMethodDecl:abstractMethod {: RESULT=new AbstractClassAbstractMethodDeclaration(access, abstractMethod); RESULT.setLine(accessleft); :}
                          | (ErrorAbstractClassMethodDeclaration) error SEMICOLON {: parser.report_error("Invalid abstract class method declaration!", null); :} {: RESULT=new ErrorAbstractClassMethodDeclaration(); :}
                          ;

/* Method Declarations */

MethodDecl ::= (MethodDeclaration) MethodHeader:M1 LPAREN OptFormalParamList:O2 RPAREN OptLocalVarDeclList:O3 LBRACE OptStatementList:O4 RBRACE {: RESULT=new MethodDeclaration(M1, O2, O3, O4); RESULT.setLine(M1left); :};

MethodHeader ::= (MethodHeader) RetType:type IDENT:name {: RESULT=new MethodHeader(type, name); RESULT.setLine(typeleft); :};

AbstractMethodDecl ::= (AbstractMethodDeclaration) AbstractMethodHeader:A1 LPAREN OptFormalParamList:O2 RPAREN SEMICOLON {: RESULT=new AbstractMethodDeclaration(A1, O2); RESULT.setLine(A1left); :};

AbstractMethodHeader ::= (AbstractMethodHeader) ABSTRACT RetType:type IDENT:name {: RESULT=new AbstractMethodHeader(type, name); RESULT.setLine(typeleft); :};

RetType ::= (ReturnType) Type:type {: RESULT=new ReturnType(type); RESULT.setLine(typeleft); :}
          | (ReturnVoid) VOID {: RESULT=new ReturnVoid(); :}
          ;

/* Formal Parameters */

OptFormalParamList ::= (FormalParameters) FormalParamList:F1 {: RESULT=new FormalParameters(F1); RESULT.setLine(F1left); :}
                     | (NoFormalParameters) {: RESULT=new NoFormalParameters(); :} /* epsilon */
                     ;

FormalParamList ::= (MultipleFormalParameters) FormalParamList:F1 COMMA FormalParam:F2 {: RESULT=new MultipleFormalParameters(F1, F2); RESULT.setLine(F1left); :}
                  | (SingleFormalParameter) FormalParam:F1 {: RESULT=new SingleFormalParameter(F1); RESULT.setLine(F1left); :}
                  ;

FormalParam ::= (FormalParameter) Type:type IDENT:name OptArrayBrackets:O1 {: RESULT=new FormalParameter(type, name, O1); RESULT.setLine(typeleft); :}
              | (ErrorFormalParameter) error {: parser.report_error("Invalid formal parameter!", null); :} {: RESULT=new ErrorFormalParameter(); :}
              ;

/* Local Var Declarations */

OptLocalVarDeclList ::= (LocalVarDeclarations) OptLocalVarDeclList:O1 LocalVarDecl:L2 {: RESULT=new LocalVarDeclarations(O1, L2); RESULT.setLine(O1left); :}
                      | (NoLocalVarDeclarations) {: RESULT=new NoLocalVarDeclarations(); :} /* epsilon */
                      ;

LocalVarDecl ::= (LocalVarDeclaration) Type:type LocalVarList:L1 SEMICOLON {: RESULT=new LocalVarDeclaration(type, L1); RESULT.setLine(typeleft); :}
               | (ErrorLocalVarDeclaration) error SEMICOLON {: parser.report_error("Invalid local variable declaration!", null); :} {: RESULT=new ErrorLocalVarDeclaration(); :}
               ;

LocalVarList ::= (LocalVariables) LocalVarList:L1 COMMA LocalVar:L2 {: RESULT=new LocalVariables(L1, L2); RESULT.setLine(L1left); :}
               | (SingleLocalVariable) LocalVar:L1 {: RESULT=new SingleLocalVariable(L1); RESULT.setLine(L1left); :}
               ;

LocalVar ::= (LocalVariable) IDENT:name OptArrayBrackets:O1 {: RESULT=new LocalVariable(name, O1); RESULT.setLine(nameleft); :}
           | (ErrorLocalVariable) error {: parser.report_error("Invalid local variable declaration!", null); :} {: RESULT=new ErrorLocalVariable(); :}
           ;


/* Statement-related non-terminals */

OptStatementList ::= (Statements) OptStatementList:O1 Statement:S2 {: RESULT=new Statements(O1, S2); RESULT.setLine(O1left); :}
                   | (NoStatements) {: RESULT=new NoStatements(); :} /* epsilon */
                   ;

Statement ::= (SingleStatement) DesignatorStatement:D1 SEMICOLON {: RESULT=new SingleStatement(D1); RESULT.setLine(D1left); :}
            | (IfOptElseStatement) IF LPAREN Condition:ifCondition RPAREN Statement:ifStatement OptElseStatement:O1 {: RESULT=new IfOptElseStatement(ifCondition, ifStatement, O1); RESULT.setLine(ifConditionleft); :}
            | (ForStatement) FOR LPAREN OptDesignatorStatement:initStatement SEMICOLON ForCondition:forCondition SEMICOLON OptDesignatorStatement:updateStatement RPAREN Statement:forStatement {: RESULT=new ForStatement(initStatement, forCondition, updateStatement, forStatement); RESULT.setLine(initStatementleft); :}
            | (ForEachStatement) FOREACH LPAREN IDENT:name COLON Designator:designator RPAREN Statement:forEachStatement {: RESULT=new ForEachStatement(name, designator, forEachStatement); RESULT.setLine(nameleft); :}
            | (BreakStatement) BREAK SEMICOLON {: RESULT=new BreakStatement(); :}
            | (ContinueStatement) CONTINUE SEMICOLON {: RESULT=new ContinueStatement(); :}
            | (ReturnStatement) RETURN OptExpr:returnValue SEMICOLON {: RESULT=new ReturnStatement(returnValue); RESULT.setLine(returnValueleft); :}
            | (ReadStatement) READ LPAREN Designator:result RPAREN SEMICOLON {: RESULT=new ReadStatement(result); RESULT.setLine(resultleft); :}
            | (PrintStatement) PRINT LPAREN PrintExpr:P1 RPAREN SEMICOLON {: RESULT=new PrintStatement(P1); RESULT.setLine(P1left); :}
            | (StatementBlock) LBRACE OptStatementList:O1 RBRACE {: RESULT=new StatementBlock(O1); RESULT.setLine(O1left); :}
            ;

OptDesignatorStatement ::= (SingleDesignatorStatement) DesignatorStatement:D1 {: RESULT=new SingleDesignatorStatement(D1); RESULT.setLine(D1left); :}
                         | (NoDesignatorStatement) {: RESULT=new NoDesignatorStatement(); :} /* epsilon */
                         ;

DesignatorStatement ::= (MethodCall) Designator:name LPAREN OptActualParamList:params RPAREN {: RESULT=new MethodCall(name, params); RESULT.setLine(nameleft); :}
                      | (Assignment) Designator:result AssignExpr:assignExpr {: RESULT=new Assignment(result, assignExpr); RESULT.setLine(resultleft); :}
                      | (VariableIncrement) Designator:result PLUSPLUS {: RESULT=new VariableIncrement(result); RESULT.setLine(resultleft); :}
                      | (VariableDecrement) Designator:result MINUSMINUS {: RESULT=new VariableDecrement(result); RESULT.setLine(resultleft); :}
                      ;

OptElseStatement ::= (ElseStatement) ELSE Statement:elseStatement {: RESULT=new ElseStatement(elseStatement); RESULT.setLine(elseStatementleft); :}
                   | (NoElseStatment) {: RESULT=new NoElseStatment(); :} /* epsilon */
                   ;

PrintExpr ::= (PrintOnlyExpression) Expr:printExpr {: RESULT=new PrintOnlyExpression(printExpr); RESULT.setLine(printExprleft); :}
            | (PrintExpressionAndConst) Expr:printExpr COMMA INT:constValue {: RESULT=new PrintExpressionAndConst(printExpr, constValue); RESULT.setLine(printExprleft); :}
            ;

AssignExpr ::= (AssignmentExpression) Assignop:op Expr:expr {: RESULT=new AssignmentExpression(op, expr); RESULT.setLine(opleft); :}
             | (ErrorAssignmentExpression) error {: parser.report_error("Invalid assignment expression!", null); :} {: RESULT=new ErrorAssignmentExpression(); :}
             ;

/* Designator-related non-terminals */

Designator ::= (Designator) IDENT:name OptDesignatorPartList:O1 {: RESULT=new Designator(name, O1); RESULT.setLine(nameleft); :};

OptDesignatorPartList ::= (DesignatorParts) OptDesignatorPartList:O1 DesignatorPart:D2 {: RESULT=new DesignatorParts(O1, D2); RESULT.setLine(O1left); :}
                        | (NoDesignatorParts) {: RESULT=new NoDesignatorParts(); :} /* epsilon */
                        ;

DesignatorPart ::= (FieldAccess) DOT IDENT:name {: RESULT=new FieldAccess(name); RESULT.setLine(nameleft); :}
                 | (ArrayAccess) LBRACK Expr:indexExpression RBRACK {: RESULT=new ArrayAccess(indexExpression); RESULT.setLine(indexExpressionleft); :}
                 ;

/* Expression-related non-terminals */

OptExpr ::= (SingleExpression) Expr:E1 {: RESULT=new SingleExpression(E1); RESULT.setLine(E1left); :}
          | (NoExpression) {: RESULT=new NoExpression(); :} /* epsilon */
          ;

Expr ::= (Expression) OptSign:O1 Term:T2 OptAddopExprList:O3 {: RESULT=new Expression(O1, T2, O3); RESULT.setLine(O1left); :};

/* Actual Parameters */

OptActualParamList ::= (ActualParameters) ActualParamList:A1 {: RESULT=new ActualParameters(A1); RESULT.setLine(A1left); :}
                     | (NoActualParameters) {: RESULT=new NoActualParameters(); :} /* epsilon */
                     ;

ActualParamList ::= (MultipleActualParameters) ActualParamList:A1 COMMA ActualParam:A2 {: RESULT=new MultipleActualParameters(A1, A2); RESULT.setLine(A1left); :}
                  | (SingleActualParameter) ActualParam:A1 {: RESULT=new SingleActualParameter(A1); RESULT.setLine(A1left); :}
                  ;

ActualParam ::= (ActualParameter) Expr:expr {: RESULT=new ActualParameter(expr); RESULT.setLine(exprleft); :};


/* Relational Operators */

ForCondition ::= (SingleCondition) Condition:C1 {: RESULT=new SingleCondition(C1); RESULT.setLine(C1left); :}
               | (NoCondition) {: RESULT=new NoCondition(); :} /* epsilon */
               | (ErrorCondition) error {: parser.report_error("Invalid for statement condition!", null); :} {: RESULT=new ErrorCondition(); :}
               ;

Condition ::= (MultipleConditionTerms) Condition:C1 OR CondTerm:C2 {: RESULT=new MultipleConditionTerms(C1, C2); RESULT.setLine(C1left); :}
            | (SingleConditionTerm) CondTerm:C1 {: RESULT=new SingleConditionTerm(C1); RESULT.setLine(C1left); :}
            ;

CondTerm ::= (MultipleConditionFacts) CondTerm:C1 AND CondFact:C2 {: RESULT=new MultipleConditionFacts(C1, C2); RESULT.setLine(C1left); :}
           | (SingleConditionFact) CondFact:C1 {: RESULT=new SingleConditionFact(C1); RESULT.setLine(C1left); :}
           ;

CondFact ::= (SimpleFact) Expr:expr {: RESULT=new SimpleFact(expr); RESULT.setLine(exprleft); :}
           | (ComplexFact) Expr:leftExpr Relop:op Expr:rightExpr {: RESULT=new ComplexFact(leftExpr, op, rightExpr); RESULT.setLine(leftExprleft); :}
           ;

Relop ::= (EqualityOperator) EQL {: RESULT=new EqualityOperator(); :}
        | (InequalityOperator) NEQ {: RESULT=new InequalityOperator(); :}
        | (GreaterThanOperator) GRT {: RESULT=new GreaterThanOperator(); :}
        | (GreaterOrEqualOperator) GEQ {: RESULT=new GreaterOrEqualOperator(); :}
        | (LessThanOperator) LSS {: RESULT=new LessThanOperator(); :}
        | (LessOrEqualOperator) LEQ {: RESULT=new LessOrEqualOperator(); :}
        ;

/* Additive Operators */

OptAddopExprList ::= (AddopExpressions) OptAddopExprList:list Addop:op Term:term {: RESULT=new AddopExpressions(list, op, term); RESULT.setLine(listleft); :}
                   | (NoAddopExpressions) {: RESULT=new NoAddopExpressions(); :} /* epsilon */
                   ;

Addop ::= (AddLeftOperator) AddopLeft:A1 {: RESULT=new AddLeftOperator(A1); RESULT.setLine(A1left); :}
        | (AddRightOperator) AddopRight:A1 {: RESULT=new AddRightOperator(A1); RESULT.setLine(A1left); :}
        ;

AddopLeft ::= (Add) PLUS {: RESULT=new Add(); :}
            | (Sub) MINUS {: RESULT=new Sub(); :}
            ;

AddopRight ::= (AddAssign) PLUS_ASSIGN {: RESULT=new AddAssign(); :}
             | (SubAssign) MINUS_ASSIGN {: RESULT=new SubAssign(); :}
             ;

/* Multiplicative Operators */

Term ::= (Term) Factor:F1 OptMulopExprList:O2 {: RESULT=new Term(F1, O2); RESULT.setLine(F1left); :};

Factor ::= (DesignatorFactor) Designator:D1 {: RESULT=new DesignatorFactor(D1); RESULT.setLine(D1left); :}
         | (FunctionCallFactor) Designator:D1 LPAREN OptActualParamList:O2 RPAREN {: RESULT=new FunctionCallFactor(D1, O2); RESULT.setLine(D1left); :}
         | (ConstantFactor) ConstFactor:C1 {: RESULT=new ConstantFactor(C1); RESULT.setLine(C1left); :}
         | (ObjectAllocateFactor) NEW Type:objectType {: RESULT=new ObjectAllocateFactor(objectType); RESULT.setLine(objectTypeleft); :}
         | (ArrayAllocateFactor) NEW Type:objectType LBRACK Expr:arrayExpr RBRACK {: RESULT=new ArrayAllocateFactor(objectType, arrayExpr); RESULT.setLine(objectTypeleft); :}
         | (ParenthesesExpressionFactor) LPAREN Expr:expr RPAREN {: RESULT=new ParenthesesExpressionFactor(expr); RESULT.setLine(exprleft); :}
         ;

ConstFactor ::= (ConstFactorInt) INT:value {: RESULT=new ConstFactorInt(value); RESULT.setLine(valueleft); :}
              | (ConstFactorChar) CHAR:value {: RESULT=new ConstFactorChar(value); RESULT.setLine(valueleft); :}
              | (ConstFactorBool) BOOL:value {: RESULT=new ConstFactorBool(value); RESULT.setLine(valueleft); :}
              ;

OptMulopExprList ::= (MulopExpressions) OptMulopExprList:list Mulop:op Factor:factor {: RESULT=new MulopExpressions(list, op, factor); RESULT.setLine(listleft); :}
                   | (NoMulopExpressions) {: RESULT=new NoMulopExpressions(); :} /* epsilon */
                   ;

Mulop ::= (MulLeftOperator) MulopLeft:M1 {: RESULT=new MulLeftOperator(M1); RESULT.setLine(M1left); :}
        | (MulRightOperator) MulopRight:M1 {: RESULT=new MulRightOperator(M1); RESULT.setLine(M1left); :}
        ;

MulopLeft ::= (Mul) ASTERISK {: RESULT=new Mul(); :}
            | (Div) SLASH {: RESULT=new Div(); :}
            | (Mod) PERCENT {: RESULT=new Mod(); :}
            ;

MulopRight ::= (MulAssign) ASTERISK_ASSIGN {: RESULT=new MulAssign(); :}
             | (DivAssign) SLASH_ASSIGN {: RESULT=new DivAssign(); :}
             | (ModAssign) PERCENT_ASSIGN {: RESULT=new ModAssign(); :}
             ;

/* Assignment Operators */

Assignop ::= (AssignOperator) ASSIGN {: RESULT=new AssignOperator(); :}
           | (AddAssignOperator) AddopRight:A1 {: RESULT=new AddAssignOperator(A1); RESULT.setLine(A1left); :}
           | (MulAssignOperator) MulopRight:M1 {: RESULT=new MulAssignOperator(M1); RESULT.setLine(M1left); :}
           ;