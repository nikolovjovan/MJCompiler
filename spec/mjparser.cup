package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:
    Logger log = Logger.getLogger(getClass());
    int errorCount = 0;

    private String format_message(String message, int left, int right) {
        if (left <= 0) return message;
        StringBuilder info = new StringBuilder(((MJLexer) getScanner()).fileName);
        info.append(':');
        errorCount++;
        info.append(left).append(':');
        if (right > 0) info.append(right).append(':');
        return info.append(' ').append(message).toString();
    }

    private String format_message(String message, Object info) {
        if (info instanceof Symbol) {
            Symbol sym = (Symbol) info;
            return format_message(message, sym.left, sym.right);
        }
        return format_message(message, -1, -1);
    }

    public void report_error(String message, int left, int right) {
        String formattedMessage = format_message(message, left, right);
        log.error(formattedMessage);
        System.err.println(formattedMessage);
    }

    public void report_error(String message, Object info) {
        String formattedMessage = format_message(message, info);
        log.error(formattedMessage);
        System.err.println(formattedMessage);
    }

    public void report_fatal_error(String message, Object info) throws Exception {
        done_parsing();
        String formattedMessage = format_message(message, info);
        log.fatal(formattedMessage);
        System.err.println(formattedMessage);
        throw new Exception("Cannot recover from previous error(s)!");
    }

    public void syntax_error(Symbol cur_token) {
        report_error("Syntax error!", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
        report_fatal_error("Unrecovered syntax error! Recovery impossible!", cur_token);
    }

    public int getErrorCount() { return errorCount; }
:}

scan with {:
    Symbol s = getScanner().next_token();
    if (s != null && s.value != null)
        log.info(s.toString() + (s.value != null ? " " + s.value.toString() : ""));
    return s;
:}

/* Keywords */
terminal PROGRAM, BREAK, CLASS, ABSTRACT, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, FOR, EXTENDS, CONTINUE,
         FOREACH, PUBLIC, PROTECTED, PRIVATE;

/* Operators */
terminal PLUS, MINUS, ASTERISK, SLASH, PERCENT, EQL, NEQ, GRT, GEQ, LSS, LEQ, AND, OR, ASSIGN, PLUSPLUS, MINUSMINUS,
         PLUS_ASSIGN, MINUS_ASSIGN, ASTERISK_ASSIGN, SLASH_ASSIGN, PERCENT_ASSIGN;

/* Punctuation symbols */
terminal LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE, COLON, SEMICOLON, COMMA, DOT;

/* Types and identifier */
terminal Integer INT;
terminal Character CHAR;
terminal Boolean BOOL;
terminal String IDENT;

/* Main non-terminals */
nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgramName, Type;
nonterminal OptProgramDeclList, ProgramDecl, OptMethodDeclList;

/* Const Declarations */
nonterminal ConstDecl, ConstAssignmentList, ConstAssignment, Const, OptSign;

/* Global Var Declarations */
nonterminal VarDecl, VarList, Var, OptArrayBrackets;

/* Class Declarations */
nonterminal ClassDecl, ClassHeader, AccessModifier, OptClassBaseType;

/* Class Var Declarations */
nonterminal OptClassVarDeclList, ClassVarDecl, ClassVarList, ClassVar;

/* Class Method Declarations */
nonterminal OptClassMethodDeclList, ClassMethodDeclList, ClassMethodDecl;

/* Abstract Class Declarations */
nonterminal AbstractClassDecl, AbstractClassHeader;

/* Abstract Class Method Declarations */
nonterminal OptAbstractClassMethodDeclList, AbstractClassMethodDeclList, AbstractClassMethodDecl;

/* Method Declarations */
nonterminal MethodDecl, AbstractMethodDecl;
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodHeader, AbstractMethodHeader, RetType;

/* Formal Parameters */
nonterminal OptFormalParamList, FormalParamList, FormalParam;

/* Local Var Declarations */
nonterminal OptLocalVarDeclList, LocalVarDecl, LocalVarList, LocalVar;

/* Statement-related non-terminals */
nonterminal OptStatementList, Statement, OptDesignatorStatement, DesignatorStatement, OptElseStatement, PrintExpr, AssignExpr;

/* Designator-related non-terminals */
nonterminal Designator, OptDesignatorPartList, DesignatorPart;

/* Expression-related non-terminals */
nonterminal OptExpr, Expr;

/* Actual Parameters */
nonterminal OptActualParamList, ActualParamList, ActualParam;

/* Relational Operators */
nonterminal ForCondition, Condition, CondTerm, CondFact, Relop;

/* Additive Operators */
nonterminal OptAddopExprList, Addop, AddopLeft, AddopRight;

/* Multiplicative Operators */
nonterminal Term, Factor, ConstFactor, OptMulopExprList, Mulop, MulopLeft, MulopRight;

/* Assignment Operators */
nonterminal Assignop;

/* Precedence for ELSE terminal for if-else statement */
precedence left ELSE;

/* Main non-terminals */

Program ::= (Program) PROGRAM ProgramName OptProgramDeclList LBRACE OptMethodDeclList RBRACE;

ProgramName ::= (ProgramName) IDENT:name;

Type ::= (Type) IDENT:name;

OptProgramDeclList ::= (ProgramDeclarations) OptProgramDeclList ProgramDecl
                     | (NoProgramDeclarations) /* epsilon */
                     ;

ProgramDecl ::= (ProgramConstDeclaration) ConstDecl
              | (ProgramVarDeclaration) VarDecl
              | (ProgramClassDeclaration) ClassDecl
              | (ProgramAbstractClassDeclaration) AbstractClassDecl
              ;

OptMethodDeclList ::= (MethodDeclarations) OptMethodDeclList MethodDecl
                    | (NoMethodDeclarations) /* epsilon */
                    ;

/* Const Declarations */

ConstDecl ::= (ConstDeclaration) CONST Type:type ConstAssignmentList SEMICOLON;

ConstAssignmentList ::= (ConstAssignments) ConstAssignmentList COMMA ConstAssignment
                      | (SingleConstAssignment) ConstAssignment
                      ;

ConstAssignment ::= (ConstAssignment) IDENT:name ASSIGN Const:value;

Const ::= (ConstInt) OptSign:sign INT:value
        | (ConstChar) CHAR:value
        | (ConstBool) BOOL:value
        ;

OptSign ::= (Negative) MINUS
          | (ExplicitlyPositive) PLUS
          | (ImplicitlyPositive) /* epsilon */
          ;

/* Var Declarations */

VarDecl ::= (VarDeclaration) Type:type VarList SEMICOLON;

VarList ::= (Variables) VarList COMMA Var
          | (SingleVariable) Var
          ;

Var ::= (Variable) IDENT:name OptArrayBrackets;

OptArrayBrackets ::= (ArrayBrackets) LBRACK RBRACK
                   | (NoArrayBrackets) /* epsilon */
                   ;

/* Class Declarations */

ClassDecl ::= (ClassDeclaration) ClassHeader LBRACE OptClassVarDeclList OptClassMethodDeclList RBRACE;

ClassHeader ::= (ClassHeader) CLASS IDENT:name OptClassBaseType;

AccessModifier ::= (PublicAccess) PUBLIC
                 | (ProtectedAccess) PROTECTED
                 | (PrivateAccess) PRIVATE
                 ;

OptClassBaseType ::= (ClassBaseType) EXTENDS Type:type
                   | (NoClassBaseType) /* epsilon */
                   | (ErrorClassBaseTypeAfterExtends) EXTENDS error {: parser.report_error("Invalid class base type declaration!", null); :}
                   | (ErrorClassBaseTypeBeforeExtends) error {: parser.report_error("Invalid class base type declaration!", null); :}
                   ;

/* Class Var Declarations */

OptClassVarDeclList ::= (ClassVarDeclarations) OptClassVarDeclList ClassVarDecl
                      | (NoClassVarDeclarations) /* epsilon */
                      ;

ClassVarDecl ::= (ClassVarDeclaration) AccessModifier:access Type:type ClassVarList SEMICOLON;

ClassVarList ::= (ClassVariables) ClassVarList COMMA ClassVar
               | (SingleClassVariable) ClassVar
               ;

ClassVar ::= (ClassVariable) IDENT:name OptArrayBrackets;

/* Class Method Declarations */

OptClassMethodDeclList ::= (ClassMethodDeclarations) LBRACE ClassMethodDeclList RBRACE
                         | (NoClassMethodDeclarations) /* epsilon */
                         ;

ClassMethodDeclList ::= (MultipleClassMethodDeclarations) ClassMethodDeclList ClassMethodDecl
                      | (SingleClassMethodDeclaration) ClassMethodDecl
                      ;

ClassMethodDecl ::= (ClassMethodDeclaration) AccessModifier:access MethodDecl:method;

/* Abstract Class Declarations */

AbstractClassDecl ::= (AbstractClassDeclaration) AbstractClassHeader LBRACE OptClassVarDeclList OptAbstractClassMethodDeclList RBRACE;

AbstractClassHeader ::= (AbstractClassHeader) ABSTRACT CLASS IDENT:name OptClassBaseType;

/* Abstract Class Method Declarations */

OptAbstractClassMethodDeclList ::= (AbstractClassMethods) LBRACE AbstractClassMethodDeclList RBRACE
                                 | (NoAbstractClassMethods) /* epsilon */
                                 ;

AbstractClassMethodDeclList ::= (MultipleAbstractClassMethods) AbstractClassMethodDeclList AbstractClassMethodDecl
                              | (SingleAbstractClassMethod) AbstractClassMethodDecl
                              ;

AbstractClassMethodDecl ::= (AbstractClassMethodDeclaration) AccessModifier:access MethodDecl:method
                          | (AbstractClassAbstractMethodDeclaration) AccessModifier:access AbstractMethodDecl:abstractMethod
                          | (ErrorAbstractClassMethodDeclaration) error SEMICOLON {: parser.report_error("Invalid abstract class method declaration!", null); :}
                          ;

/* Method Declarations */

MethodDecl ::= (MethodDeclaration) MethodHeader LPAREN OptFormalParamList RPAREN OptLocalVarDeclList LBRACE OptStatementList RBRACE;

MethodHeader ::= (MethodHeader) RetType:type IDENT:name;

AbstractMethodDecl ::= (AbstractMethodDeclaration) AbstractMethodHeader LPAREN OptFormalParamList RPAREN SEMICOLON;

AbstractMethodHeader ::= (AbstractMethodHeader) ABSTRACT RetType:type IDENT:name;

RetType ::= (ReturnType) Type:type
          | (ReturnVoid) VOID
          ;

/* Formal Parameters */

OptFormalParamList ::= (FormalParameters) FormalParamList
                     | (NoFormalParameters) /* epsilon */
                     ;

FormalParamList ::= (MultipleFormalParameters) FormalParamList COMMA FormalParam
                  | (SingleFormalParameter) FormalParam
                  ;

FormalParam ::= (FormalParameter) Type:type IDENT:name OptArrayBrackets
              | (ErrorFormalParameter) error {: parser.report_error("Invalid formal parameter!", null); :}
              ;

/* Local Var Declarations */

OptLocalVarDeclList ::= (LocalVarDeclarations) OptLocalVarDeclList LocalVarDecl
                      | (NoLocalVarDeclarations) /* epsilon */
                      ;

LocalVarDecl ::= (LocalVarDeclaration) Type:type LocalVarList SEMICOLON
               | (ErrorLocalVarDeclaration) error SEMICOLON {: parser.report_error("Invalid local variable declaration!", null); :}
               ;

LocalVarList ::= (LocalVariables) LocalVarList COMMA LocalVar
               | (SingleLocalVariable) LocalVar
               ;

LocalVar ::= (LocalVariable) IDENT:name OptArrayBrackets
           | (ErrorLocalVariable) error {: parser.report_error("Invalid local variable declaration!", null); :}
           ;


/* Statement-related non-terminals */

OptStatementList ::= (Statements) OptStatementList Statement
                   | (NoStatements) /* epsilon */
                   ;

Statement ::= (SingleStatement) DesignatorStatement SEMICOLON
            | (IfOptElseStatement) IF LPAREN Condition:ifCondition RPAREN Statement:ifStatement OptElseStatement
            | (ForStatement) FOR LPAREN OptDesignatorStatement:initStatement SEMICOLON ForCondition:forCondition SEMICOLON OptDesignatorStatement:updateStatement RPAREN Statement:forStatement
            | (ForEachStatement) FOREACH LPAREN IDENT:name COLON Designator:designator RPAREN Statement:forEachStatement
            | (BreakStatement) BREAK SEMICOLON
            | (ContinueStatement) CONTINUE SEMICOLON
            | (ReturnStatement) RETURN OptExpr:returnValue SEMICOLON
            | (ReadStatement) READ LPAREN Designator:result RPAREN SEMICOLON
            | (PrintStatement) PRINT LPAREN PrintExpr RPAREN SEMICOLON
            | (StatementBlock) LBRACE OptStatementList RBRACE
            ;

OptDesignatorStatement ::= (SingleDesignatorStatement) DesignatorStatement
                         | (NoDesignatorStatement) /* epsilon */
                         ;

DesignatorStatement ::= (MethodCall) Designator:name LPAREN OptActualParamList:params RPAREN
                      | (Assignment) Designator:result AssignExpr:assignExpr
                      | (VariableIncrement) Designator:result PLUSPLUS
                      | (VariableDecrement) Designator:result MINUSMINUS
                      ;

OptElseStatement ::= (ElseStatement) ELSE Statement:elseStatement
                   | (NoElseStatment) /* epsilon */
                   ;

PrintExpr ::= (PrintOnlyExpression) Expr:printExpr
            | (PrintExpressionAndConst) Expr:printExpr COMMA INT:constValue
            ;

AssignExpr ::= (AssignmentExpression) Assignop:op Expr:expr
             | (ErrorAssignmentExpression) error {: parser.report_error("Invalid assignment expression!", null); :}
             ;

/* Designator-related non-terminals */

Designator ::= (Designator) IDENT:name OptDesignatorPartList;

OptDesignatorPartList ::= (DesignatorParts) OptDesignatorPartList DesignatorPart
                        | (NoDesignatorParts) /* epsilon */
                        ;

DesignatorPart ::= (FieldAccess) DOT IDENT:name
                 | (ArrayAccess) LBRACK Expr:indexExpression RBRACK
                 ;

/* Expression-related non-terminals */

OptExpr ::= (SingleExpression) Expr
          | (NoExpression) /* epsilon */
          ;

Expr ::= (Expression) OptSign Term OptAddopExprList;

/* Actual Parameters */

OptActualParamList ::= (ActualParameters) ActualParamList
                     | (NoActualParameters) /* epsilon */
                     ;

ActualParamList ::= (MultipleActualParameters) ActualParamList COMMA ActualParam
                  | (SingleActualParameter) ActualParam
                  ;

ActualParam ::= (ActualParameter) Expr:expr;


/* Relational Operators */

ForCondition ::= (SingleCondition) Condition
               | (NoCondition) /* epsilon */
               | (ErrorCondition) error {: parser.report_error("Invalid for statement condition!", null); :}
               ;

Condition ::= (MultipleConditionTerms) Condition OR CondTerm
            | (SingleConditionTerm) CondTerm
            ;

CondTerm ::= (MultipleConditionFacts) CondTerm AND CondFact
           | (SingleConditionFact) CondFact
           ;

CondFact ::= (SimpleFact) Expr:expr
           | (ComplexFact) Expr:leftExpr Relop:op Expr:rightExpr
           ;

Relop ::= (EqualityOperator) EQL
        | (InequalityOperator) NEQ
        | (GreaterThanOperator) GRT
        | (GreaterOrEqualOperator) GEQ
        | (LessThanOperator) LSS
        | (LessOrEqualOperator) LEQ
        ;

/* Additive Operators */

OptAddopExprList ::= (AddopExpressions) OptAddopExprList:list Addop:op Term:term
                   | (NoAddopExpressions) /* epsilon */
                   ;

Addop ::= (AddLeftOperator) AddopLeft
        | (AddRightOperator) AddopRight
        ;

AddopLeft ::= (Add) PLUS
            | (Sub) MINUS
            ;

AddopRight ::= (AddAssign) PLUS_ASSIGN
             | (SubAssign) MINUS_ASSIGN
             ;

/* Multiplicative Operators */

Term ::= (Term) Factor OptMulopExprList;

Factor ::= (DesignatorFactor) Designator
         | (FunctionCallFactor) Designator LPAREN OptActualParamList RPAREN
         | (ConstantFactor) ConstFactor
         | (ObjectAllocateFactor) NEW Type:objectType
         | (ArrayAllocateFactor) NEW Type:objectType LBRACK Expr:arrayExpr RBRACK
         | (ParenthesesExpressionFactor) LPAREN Expr:expr RPAREN
         ;

ConstFactor ::= (ConstFactorInt) INT:value
              | (ConstFactorChar) CHAR:value
              | (ConstFactorBool) BOOL:value
              ;

OptMulopExprList ::= (MulopExpressions) OptMulopExprList:list Mulop:op Factor:factor
                   | (NoMulopExpressions) /* epsilon */
                   ;

Mulop ::= (MulLeftOperator) MulopLeft
        | (MulRightOperator) MulopRight
        ;

MulopLeft ::= (Mul) ASTERISK
            | (Div) SLASH
            | (Mod) PERCENT
            ;

MulopRight ::= (MulAssign) ASTERISK_ASSIGN
             | (DivAssign) SLASH_ASSIGN
             | (ModAssign) PERCENT_ASSIGN
             ;

/* Assignment Operators */

Assignop ::= (AssignOperator) ASSIGN
           | (AddAssignOperator) AddopRight
           | (MulAssignOperator) MulopRight
           ;