package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.Level;
import rs.ac.bg.etf.pp1.ast.*;
import rs.ac.bg.etf.pp1.exceptions.MJParserException;
import rs.ac.bg.etf.pp1.loggers.MJParserLogger;
import rs.ac.bg.etf.pp1.loggers.MJParserLogger.MessageType;

parser code {:
  private MJParserLogger logger = new MJParserLogger();

  private int errorCount = 0;

  private void log(Level level, MessageType type, String message, Object info) {
    int line = -1, column = -1;
    if (info instanceof Symbol) {
      Symbol sym = (Symbol) info;
      line = sym.left;
      column = sym.right;
    }
    if (message != null) logger.log(level, line, column, type, message);
    else logger.log(level, line, column, type);
    if (level == Level.ERROR || level == Level.FATAL) errorCount++;
  }

  private void log_fatal(MessageType type, String message, Object info) throws Exception {
    log(Level.FATAL, type, message, info);
    done_parsing();
    throw new MJParserException("Cannot recover from previous error(s)!");
  }

  private void log_error(MessageType type, String message, Object info) {
    log(Level.ERROR, type, message, info);
  }

  void log_error(MessageType type) {
    log(Level.ERROR, type, null, null);
  }

  public int getErrorCount() { return errorCount; }

  @Override
  public void report_error(String message, Object info) {
    log_error(MessageType.OTHER, message, info);
  }

  @Override
  public void report_fatal_error(String message, Object info) throws Exception {
    log_fatal(MessageType.OTHER, message, info);
  }

  @Override
  public void syntax_error(Symbol cur_token) {
    log_error(MessageType.SYNTAX_ERROR, null, cur_token);
  }

  @Override
  public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
    log_fatal(MessageType.IRR_SYNTAX_ERROR, null, cur_token);
  }
:}

/* Keywords */
terminal PROGRAM, BREAK, CLASS, ABSTRACT, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, FOR, EXTENDS, CONTINUE,
         FOREACH, PUBLIC, PROTECTED, PRIVATE;

/* Operators */
terminal PLUS, MINUS, ASTERISK, SLASH, PERCENT, EQL, NEQ, GRT, GEQ, LSS, LEQ, AND, OR, ASSIGN, PLUSPLUS, MINUSMINUS,
         PLUS_ASSIGN, MINUS_ASSIGN, ASTERISK_ASSIGN, SLASH_ASSIGN, PERCENT_ASSIGN;

/* Punctuation symbols */
terminal LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE, COLON, SEMICOLON, COMMA, DOT;

/* Types and identifier */
terminal Integer INT;
terminal Character CHAR;
terminal Boolean BOOL;
terminal String IDENT;

/* Main non-terminals */
nonterminal rs.ac.bg.etf.pp1.symboltable.concepts.MJSymbol Program, ProgramName, Type;
nonterminal OptProgramDeclList, ProgramDecl, OptMethodDeclList;

/* Const Declarations */
nonterminal ConstDecl, ConstAssignmentList, ConstAssignment, Const, OptSign;

/* Global Var Declarations */
nonterminal VarDecl, VarList, Var, OptArrayBrackets;

/* Class Declarations */
nonterminal ClassDecl, ClassHeader, AccessModifier, OptClassBaseType;

/* Class Var Declarations */
nonterminal OptClassVarDeclList, ClassVarDecl, ClassVarList, ClassVar;

/* Class Method Declarations */
nonterminal OptClassMethodDeclList, ClassMethodDeclList, ClassMethodDecl;

/* Abstract Class Declarations */
nonterminal AbstractClassDecl, AbstractClassHeader;

/* Abstract Class Method Declarations */
nonterminal OptAbstractClassMethodDeclList, AbstractClassMethodDeclList, AbstractClassMethodDecl;

/* Method Declarations */
nonterminal MethodDecl, AbstractMethodDecl, MethodStatementListStart;
nonterminal rs.ac.bg.etf.pp1.symboltable.concepts.MJSymbol MethodHeader, AbstractMethodHeader, RetType;

/* Formal Parameters */
nonterminal OptFormalParamList, FormalParamList, FormalParam;

/* Local Var Declarations */
nonterminal OptLocalVarDeclList, LocalVarDecl, LocalVarList, LocalVar;

/* Statement-related non-terminals */
nonterminal OptStatementList, Statement, IfStatementHeader, ForStatementHeader, ForEachStatementHeader,
            OptDesignatorStatement, DesignatorStatement, OptElseStatement, PrintExpr, AssignExpr;
nonterminal rs.ac.bg.etf.pp1.symboltable.concepts.MJSymbol MethodCall, MethodCallHeader;

/* Designator-related non-terminals */
nonterminal rs.ac.bg.etf.pp1.symboltable.concepts.MJSymbol Designator, DesignatorHeader, OptDesignatorPartList;
nonterminal DesignatorPart;

/* Expression-related non-terminals */
nonterminal OptExpr;
nonterminal rs.ac.bg.etf.pp1.symboltable.concepts.MJSymbol Expr;

/* Actual Parameters */
nonterminal OptActualParamList, ActualParamList, ActualParam;

/* Relational Operators */
nonterminal rs.ac.bg.etf.pp1.symboltable.concepts.MJSymbol Condition, CondTerm, CondFact;
nonterminal ForCondition, Relop;

/* Additive Operators */
nonterminal OptAddopExprList, Addop, AddopLeft, AddopRight;

/* Multiplicative Operators */
nonterminal rs.ac.bg.etf.pp1.symboltable.concepts.MJSymbol Term, Factor;
nonterminal ConstFactor, OptMulopExprList, Mulop, MulopLeft, MulopRight;

/* Assignment Operators */
nonterminal Assignop;

/* Precedence for ELSE terminal for if-else statement */
precedence left ELSE;

/* Main non-terminals */

Program ::= (Program) PROGRAM ProgramName OptProgramDeclList LBRACE OptMethodDeclList RBRACE;

ProgramName ::= (ProgramName) IDENT:name;

Type ::= (Type) IDENT:name;

OptProgramDeclList ::= (ProgramDeclarations) OptProgramDeclList ProgramDecl
                     | (NoProgramDeclarations) /* epsilon */
                     ;

ProgramDecl ::= (ProgramConstDeclaration) ConstDecl
              | (ProgramVarDeclaration) VarDecl
              | (ProgramClassDeclaration) ClassDecl
              | (ProgramAbstractClassDeclaration) AbstractClassDecl
              ;

OptMethodDeclList ::= (MethodDeclarations) OptMethodDeclList MethodDecl
                    | (NoMethodDeclarations) /* epsilon */
                    ;

/* Const Declarations */

ConstDecl ::= (ConstDeclaration) CONST Type:type ConstAssignmentList SEMICOLON;

ConstAssignmentList ::= (ConstAssignments) ConstAssignmentList COMMA ConstAssignment
                      | (SingleConstAssignment) ConstAssignment
                      ;

ConstAssignment ::= (ConstAssignment) IDENT:name ASSIGN Const:value;

Const ::= (ConstInt) OptSign:sign INT:value
        | (ConstChar) CHAR:value
        | (ConstBool) BOOL:value
        ;

OptSign ::= (Negative) MINUS
          | (ExplicitlyPositive) PLUS
          | (ImplicitlyPositive) /* epsilon */
          ;

/* Var Declarations */

VarDecl ::= (VarDeclaration) Type:type VarList SEMICOLON;

VarList ::= (Variables) VarList COMMA Var
          | (SingleVariable) Var
          ;

Var ::= (Variable) IDENT:name OptArrayBrackets;

OptArrayBrackets ::= (ArrayBrackets) LBRACK RBRACK
                   | (NoArrayBrackets) /* epsilon */
                   ;

/* Class Declarations */

ClassDecl ::= (ClassDeclaration) ClassHeader LBRACE OptClassVarDeclList OptClassMethodDeclList RBRACE;

ClassHeader ::= (ClassHeader) CLASS IDENT:name OptClassBaseType;

AccessModifier ::= (PublicAccess) PUBLIC
                 | (ProtectedAccess) PROTECTED
                 | (PrivateAccess) PRIVATE
                 ;

OptClassBaseType ::= (ClassBaseType) EXTENDS Type:type
                   | (NoClassBaseType) /* epsilon */
                   | (ErrorClassBaseTypeAfterExtends) EXTENDS error {: parser.log_error(MessageType.INV_CLS_BASE_TYPE); :}
                   | (ErrorClassBaseTypeBeforeExtends) error {: parser.log_error(MessageType.INV_CLS_BASE_TYPE); :}
                   ;

/* Class Var Declarations */

OptClassVarDeclList ::= (ClassVarDeclarations) OptClassVarDeclList ClassVarDecl
                      | (NoClassVarDeclarations) /* epsilon */
                      ;

ClassVarDecl ::= (ClassVarDeclaration) AccessModifier:access Type:type ClassVarList SEMICOLON;

ClassVarList ::= (ClassVariables) ClassVarList COMMA ClassVar
               | (SingleClassVariable) ClassVar
               ;

ClassVar ::= (ClassVariable) IDENT:name OptArrayBrackets;

/* Class Method Declarations */

OptClassMethodDeclList ::= (ClassMethodDeclarations) LBRACE ClassMethodDeclList RBRACE
                         | (NoClassMethodDeclarations) /* epsilon */
                         ;

ClassMethodDeclList ::= (MultipleClassMethodDeclarations) ClassMethodDeclList ClassMethodDecl
                      | (SingleClassMethodDeclaration) ClassMethodDecl
                      ;

ClassMethodDecl ::= (ClassMethodDeclaration) AccessModifier:access MethodDecl:method;

/* Abstract Class Declarations */

AbstractClassDecl ::= (AbstractClassDeclaration) AbstractClassHeader LBRACE OptClassVarDeclList OptAbstractClassMethodDeclList RBRACE;

AbstractClassHeader ::= (AbstractClassHeader) ABSTRACT CLASS IDENT:name OptClassBaseType;

/* Abstract Class Method Declarations */

OptAbstractClassMethodDeclList ::= (AbstractClassMethods) LBRACE AbstractClassMethodDeclList RBRACE
                                 | (NoAbstractClassMethods) /* epsilon */
                                 ;

AbstractClassMethodDeclList ::= (MultipleAbstractClassMethods) AbstractClassMethodDeclList AbstractClassMethodDecl
                              | (SingleAbstractClassMethod) AbstractClassMethodDecl
                              ;

AbstractClassMethodDecl ::= (AbstractClassMethodDeclaration) AccessModifier:access MethodDecl:method
                          | (AbstractClassAbstractMethodDeclaration) AccessModifier:access AbstractMethodDecl:abstractMethod
                          | (ErrorAbstractClassMethodDeclaration) error SEMICOLON {: parser.log_error(MessageType.INV_ABS_CLS_METH_DECL); :}
                          ;

/* Method Declarations */

MethodDecl ::= (MethodDeclaration) MethodHeader LPAREN OptFormalParamList RPAREN OptLocalVarDeclList MethodStatementListStart OptStatementList RBRACE;

MethodHeader ::= (MethodHeader) RetType:type IDENT:name;

MethodStatementListStart ::= (MethodStatementListStart) LBRACE;

AbstractMethodDecl ::= (AbstractMethodDeclaration) AbstractMethodHeader LPAREN OptFormalParamList RPAREN SEMICOLON;

AbstractMethodHeader ::= (AbstractMethodHeader) ABSTRACT RetType:type IDENT:name;

RetType ::= (ReturnType) Type:type
          | (ReturnVoid) VOID
          ;

/* Formal Parameters */

OptFormalParamList ::= (FormalParameters) FormalParamList
                     | (NoFormalParameters) /* epsilon */
                     ;

FormalParamList ::= (MultipleFormalParameters) FormalParamList COMMA FormalParam
                  | (SingleFormalParameter) FormalParam
                  ;

FormalParam ::= (FormalParameter) Type:type IDENT:name OptArrayBrackets
              | (ErrorFormalParameter) error {: parser.log_error(MessageType.INV_FORMAL_PARAM); :}
              ;

/* Local Var Declarations */

OptLocalVarDeclList ::= (LocalVarDeclarations) OptLocalVarDeclList LocalVarDecl
                      | (NoLocalVarDeclarations) /* epsilon */
                      ;

LocalVarDecl ::= (LocalVarDeclaration) Type:type LocalVarList SEMICOLON
               | (ErrorLocalVarDeclaration) error SEMICOLON {: parser.log_error(MessageType.INV_LOCAL_VAR_DECL); :}
               ;

LocalVarList ::= (LocalVariables) LocalVarList COMMA LocalVar
               | (SingleLocalVariable) LocalVar
               ;

LocalVar ::= (LocalVariable) IDENT:name OptArrayBrackets
           | (ErrorLocalVariable) error {: parser.log_error(MessageType.INV_LOCAL_VAR_DECL); :}
           ;


/* Statement-related non-terminals */

OptStatementList ::= (Statements) OptStatementList Statement
                   | (NoStatements) /* epsilon */
                   ;

Statement ::= (SingleStatement) DesignatorStatement SEMICOLON
            | (IfOptElseStatement) IfStatementHeader:ifHeader Statement:ifStatement OptElseStatement
            | (ForStatement) ForStatementHeader:forHeader Statement:forStatement
            | (ForEachStatement) ForEachStatementHeader:forEachHeader Statement:forEachStatement
            | (BreakStatement) BREAK SEMICOLON
            | (ContinueStatement) CONTINUE SEMICOLON
            | (ReturnStatement) RETURN OptExpr:returnValue SEMICOLON
            | (ReadStatement) READ LPAREN Designator:result RPAREN SEMICOLON
            | (PrintStatement) PRINT LPAREN PrintExpr RPAREN SEMICOLON
            | (StatementBlock) LBRACE OptStatementList RBRACE
            ;

IfStatementHeader ::= (IfStatementHeader) IF LPAREN Condition:ifCondition RPAREN;

ForStatementHeader ::= (ForStatementHeader) FOR LPAREN OptDesignatorStatement:initStatement SEMICOLON ForCondition:forCondition SEMICOLON OptDesignatorStatement:updateStatement RPAREN;

ForEachStatementHeader ::= (ForEachStatementHeader) FOREACH LPAREN IDENT:name COLON Designator:designator RPAREN;

OptDesignatorStatement ::= (SingleDesignatorStatement) DesignatorStatement
                         | (NoDesignatorStatement) /* epsilon */
                         ;

DesignatorStatement ::= (AssignmentStatement) Designator:result AssignExpr:assignExpr
                      | (MethodCallStatement) MethodCall
                      | (VariableIncrementStatement) Designator:result PLUSPLUS
                      | (VariableDecrementStatement) Designator:result MINUSMINUS
                      ;

OptElseStatement ::= (ElseStatement) ELSE Statement:elseStatement
                   | (NoElseStatment) /* epsilon */
                   ;

PrintExpr ::= (PrintOnlyExpression) Expr:printExpr
            | (PrintExpressionAndConst) Expr:printExpr COMMA INT:constValue
            ;

AssignExpr ::= (AssignmentExpression) Assignop:op Expr:expr
             | (ErrorAssignmentExpression) error {: parser.log_error(MessageType.INV_ASSIGN_EXPR); :}
             ;

MethodCall ::= (MethodCall) MethodCallHeader:methodName LPAREN OptActualParamList RPAREN;

MethodCallHeader ::= (MethodCallHeader) Designator:methodName;

/* Designator-related non-terminals */

Designator ::= (Designator) DesignatorHeader OptDesignatorPartList;

DesignatorHeader ::= (DesignatorHeader) IDENT:name;

OptDesignatorPartList ::= (DesignatorParts) OptDesignatorPartList DesignatorPart
                        | (NoDesignatorParts) /* epsilon */
                        ;

DesignatorPart ::= (MemberAccess) DOT IDENT:name
                 | (ElementAccess) LBRACK Expr:indexExpression RBRACK
                 ;

/* Expression-related non-terminals */

OptExpr ::= (SingleExpression) Expr
          | (NoExpression) /* epsilon */
          ;

Expr ::= (Expression) OptSign Term OptAddopExprList;

/* Actual Parameters */

OptActualParamList ::= (ActualParameters) ActualParamList
                     | (NoActualParameters) /* epsilon */
                     ;

ActualParamList ::= (MultipleActualParameters) ActualParamList COMMA ActualParam
                  | (SingleActualParameter) ActualParam
                  ;

ActualParam ::= (ActualParameter) Expr:expr;


/* Relational Operators */

ForCondition ::= (SingleCondition) Condition
               | (NoCondition) /* epsilon */
               | (ErrorCondition) error {: parser.log_error(MessageType.INV_FOR_STMT_COND); :}
               ;

Condition ::= (MultipleConditionTerms) Condition OR CondTerm
            | (SingleConditionTerm) CondTerm
            ;

CondTerm ::= (MultipleConditionFacts) CondTerm AND CondFact
           | (SingleConditionFact) CondFact
           ;

CondFact ::= (SimpleFact) Expr:expr
           | (ComplexFact) Expr:leftExpr Relop:op Expr:rightExpr
           ;

Relop ::= (EqualityOperator) EQL
        | (InequalityOperator) NEQ
        | (GreaterThanOperator) GRT
        | (GreaterOrEqualOperator) GEQ
        | (LessThanOperator) LSS
        | (LessOrEqualOperator) LEQ
        ;

/* Additive Operators */

OptAddopExprList ::= (AddopExpressions) OptAddopExprList:list Addop:op Term:term
                   | (NoAddopExpressions) /* epsilon */
                   ;

Addop ::= (AddLeftOperator) AddopLeft
        | (AddRightOperator) AddopRight
        ;

AddopLeft ::= (Add) PLUS
            | (Sub) MINUS
            ;

AddopRight ::= (AddAssign) PLUS_ASSIGN
             | (SubAssign) MINUS_ASSIGN
             ;

/* Multiplicative Operators */

Term ::= (Term) Factor OptMulopExprList;

Factor ::= (DesignatorFactor) Designator
         | (MethodCallFactor) MethodCall
         | (ConstantFactor) ConstFactor
         | (ObjectAllocateFactor) NEW Type:objectType
         | (ArrayAllocateFactor) NEW Type:objectType LBRACK Expr:arrayExpr RBRACK
         | (ParenthesesExpressionFactor) LPAREN Expr:expr RPAREN
         ;

ConstFactor ::= (ConstFactorInt) INT:value
              | (ConstFactorChar) CHAR:value
              | (ConstFactorBool) BOOL:value
              ;

OptMulopExprList ::= (MulopExpressions) OptMulopExprList:list Mulop:op Factor:factor
                   | (NoMulopExpressions) /* epsilon */
                   ;

Mulop ::= (MulLeftOperator) MulopLeft
        | (MulRightOperator) MulopRight
        ;

MulopLeft ::= (Mul) ASTERISK
            | (Div) SLASH
            | (Mod) PERCENT
            ;

MulopRight ::= (MulAssign) ASTERISK_ASSIGN
             | (DivAssign) SLASH_ASSIGN
             | (ModAssign) PERCENT_ASSIGN
             ;

/* Assignment Operators */

Assignop ::= (AssignOperator) ASSIGN
           | (AddAssignOperator) AddopRight
           | (MulAssignOperator) MulopRight
           ;